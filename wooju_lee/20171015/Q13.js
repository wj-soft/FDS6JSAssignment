// / # 13. 최대공약수와 최소공배수
// 두 수를 입력받아 두 수의 최대공약수와 최소공배수를 반환해주는 gcdlcm 함수를 완성하라
// 배열의 맨 앞에 최대공약수, 그 다음 최소공배수를 넣어 반환한다. 예를 들어 gcdlcm(3,12)가 입력되면, [3, 12]를 반환하라
// [최대공약수(最大公約數 greatest common divisor)](https://ko.wikipedia.org/wiki/%EC%B5%9C%EB%8C%80%EA%B3%B5%EC%95%BD%EC%88%98)란,
// 0이 아닌 두 정수나 다항식의 공통되는 약수 중에서 가장 큰 수를 말한다
// 두 수 a와 b의 최대공약수를 구하는 방법은 소인수 분해를 사용하는 방법과 
// [유클리드 호제법](https://ko.wikipedia.org/wiki/%EC%9C%A0%ED%81%B4%EB%A6%AC%EB%93%9C_%ED%98%B8%EC%A0%9C%EB%B2%95)이 있다
// 일반적으로 소인수 분해를 효율적으로 빠른 시간 내에 하는 방법은 알려져 있지 않다. 더 빠른 시간 안에 구하는 방법에는 호제법이 있다
// 똑같이 두 수 192와 72의 최대공약수를 이번에는 호제법으로 구하여 보자. 일단 192을 72로 나누어 나머지를 구한다
// 192 = 72 * 2 + 48이다. 이는 192을 72로 나누어 나온 나머지가 48라는 것을 의미한다. 이번에는 72을 나머지인 48로 나눈다
// 72 = 48 * 1 + 24이다. 이와 같은 연산을 나머지가 0이 될 때까지 반복한다. 48 = 24 * 2 + 0 나머지가 0이 되었으므로 연산을 중지한다
// 이때, 나머지가 0이 되기 바로 직전의 연산에서의 나머지가 원래 두 수의 최대공약수가 된다
// 1071과 1029의 최대공약수를 구하면,
// 1071은 1029로 나누어 떨어지지 않기 때문에, 1071을 1029로 나눈 나머지를 구한다 => 42
// 1029는 42로 나누어 떨어지지 않기 때문에, 1029를 42로 나눈 나머지를 구한다 => 21
// 42는 21로 나누어 떨어진다
// 따라서, 최대공약수는 21이다

function gcdlcm(a, b) {
  var remain = 0;
  var result = [];
  var i = a;
  var j = b;
  if (b < a) {
    i = b;
    j = a;
  }
  while (j % i !== 0) {
    // console.log(i, j, remain);
    remain = j % i;
    j = i;
    i = remain;
  }

  result[0] = i;
  result[1] = a * b / i

  return result;

  // 최대공약수 = 두 수의 곱 / 최대공약수
}
console.log(gcdlcm(3, 12)); // [3, 12]
console.log(gcdlcm(72, 192));
console.log(gcdlcm(1071, 1029));